协同过滤算法
  -1. 原理：利用相似的用户或者相似的物品产生推荐列表
    利用相似的用户产生推荐列表：UserCF
      将相似用户喜好的商品作为当前用户的推荐列表
    利用相似的物品产生推荐列表：ItemCF
      将当前用户喜好物品的最相似的物品作为当前用户的推荐列表
  -2. 和KNN的区别：
    --1. 和KNN一样都是基于样本的相似度来产生预测/推荐信息的。
    --2. 输入的数据不一样：KNN中输入的特征属性构成的特征矩阵，协同过滤算法中输入的是用户物品评分矩阵
    --3. 相似度的计算方式不一样：
      KNN中基于特征属性计算相似度
      协同过滤算法中基于用户对于共同评分过的商品评分来计算相似度
    --4. 最终产生预测结果方式不一样
      KNN直接对相似物品的目标属性做一个整合
      协同过滤算法中是基于相似度产生一个评分值，最终获取评分最高的数据作为推荐结果

协同过滤中相似度的计算方式：
  -1. 将用户-物品的评分信息转换为关于用户或者关于物品的评分向量
  -2. 和KNN的计算的一样的了，将每个向量当作一个样本，直接计算向量与向量之间的相似度；一般采用欧几里得聚类、夹角余弦相似度等等
  eg:
    评分矩阵如下：
u1 i1 5
u1 i2 3
u1 i5 3
u2 i2 5
u2 i5 4
u3 i1 4
u3 i2 5
u3 i3 1
u3 i4 2
   假设计算u1和u2的相似度：
     -1. 找到u1和u2共同评论过的商品列表
       I_u1,u2 = {i2, i5}
     -2. 使用共同评论过的商品评分构建向量
       u1: (3, 3)
       u2: (5, 4)
     -3. 直接计算两个向量的相似度
   假设计算i2和i5的相似度：
     -1. 找到i2和i5都评估过的用户列表
       U_i2,i5={u1, u2}
     -2. 转换成为向量
       i2: (3, 5)
       i5: (3, 4)
     -3. 直接计算两个向量的相似度
